Note clean always first.

Graphs to virsulaize:
3, 5,6,8, 11


| #  | Analysis Goal                                          | Description / What It Shows                                                                                                | Graph Type      | X-axis   | Y-axis                  |
| -- | ------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- | --------------- | -------- | ----------------------- |
| 1  | **Compare runtime (speed) across languages**           | Shows how long programs take to execute large inputs (`z1000t`) for each language. Highlights median speed and outliers.   | Boxplot         | `lang`   | `z1000t`                |
| 2  | **Compare startup time**                               | Displays execution time on a minimal input (`z0t`) to reveal startup overhead differences between languages.               | Boxplot         | `lang`   | `z0t`                   |
| 3  | **Check scalability / efficiency growth**              | Compares performance growth from small to large input (`z1000t / z0t`). Lower ratio = better scalability.                  | Boxplot         | `lang`   | `scaling_ratio`         |
| 4  | **Compare memory usage**                               | Compares mean memory consumption for large inputs (`z1000mem`) between languages.                                          | Barplot         | `lang`   | `z1000mem`              |
| 5  | **Compare reliability across problem types**           | Displays output correctness (`z1000rel`, `m1000rel`) for two problem types to assess consistency.                          | Grouped Barplot | `lang`   | `z1000rel` & `m1000rel` |
| 6  | **Examine relation between code size and runtime**     | Tests if longer programs (`stmtL`) are slower (`z1000t`), indicating complexity/performance trade-offs.                    | Scatterplot     | `stmtL`  | `z1000t`                |
| 7  | **Check effort vs reliability**                        | Investigates whether more developer work time (`whours`) leads to higher reliability (`z1000rel`).                         | Scatterplot     | `whours` | `z1000rel`              |
| 8  | **Identify correlations between all numeric features** | Visualizes correlations between all quantitative variables (runtime, memory, reliability, etc.).                           | Heatmap         | —        | —                       |
| 9  | **Check runtime vs memory trade-off**                  | Examines whether faster programs also consume less memory, revealing efficiency trade-offs.                                | Scatterplot     | `z1000t` | `z1000mem`              |
| 10 | **Distribution of work time**                          | Shows how total developer work hours (`whours`) are distributed across all participants.                                   | Histogram       | `whours` | Frequency               |
| 11 | **Check relation between work time and code length**   | Shows whether longer programs (`stmtL`) take more developer time (`whours`) to complete. Useful for productivity analysis. | Scatterplot     | `stmtL`  | `whours`                |


| #  | Analysis Goal                                          | Python Code                                                                                                                                                                                                                                                             |
| -- | ------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | **Compare runtime (speed) across languages**           | `python\nsns.boxplot(x='lang', y='z1000t', data=df)\nplt.title('Runtime (z1000t) by Programming Language')\n`                                                                                                                                                           |
| 2  | **Compare startup time**                               | `python\nsns.boxplot(x='lang', y='z0t', data=df)\nplt.title('Startup Time (z0t) by Programming Language')\n`                                                                                                                                                            |
| 3  | **Check scalability / efficiency growth**              | `python\ndf['scaling_ratio'] = df['z1000t'] / df['z0t']\nsns.boxplot(x='lang', y='scaling_ratio', data=df)\nplt.title('Scaling Ratio (z1000t / z0t) by Language')\n`                                                                                                    |
| 4  | **Compare memory usage**                               | `python\nsns.barplot(x='lang', y='z1000mem', data=df, estimator=np.mean)\nplt.title('Average Memory Usage (z1000mem) by Language')\n`                                                                                                                                   |
| 5  | **Compare reliability across problem types**           | `python\ndf_melt = df.melt(id_vars='lang', value_vars=['z1000rel', 'm1000rel'], var_name='Test', value_name='Reliability')\nsns.barplot(x='lang', y='Reliability', hue='Test', data=df_melt)\nplt.title('Reliability Comparison (z1000rel vs m1000rel) by Language')\n` |
| 6  | **Examine relation between code size and runtime**     | `python\nsns.scatterplot(x='stmtL', y='z1000t', hue='lang', data=df)\nplt.title('Code Size (stmtL) vs Runtime (z1000t)')\n`                                                                                                                                             |
| 7  | **Check effort vs reliability**                        | `python\nsns.scatterplot(x='whours', y='z1000rel', hue='lang', data=df)\nplt.title('Work Hours (whours) vs Reliability (z1000rel)')\n`                                                                                                                                  |
| 8  | **Identify correlations between all numeric features** | `python\nplt.figure(figsize=(10,6))\nsns.heatmap(df.corr(), annot=True, cmap='coolwarm')\nplt.title('Correlation Heatmap of Numeric Features')\n`                                                                                                                       |
| 9  | **Check runtime vs memory trade-off**                  | `python\nsns.scatterplot(x='z1000t', y='z1000mem', hue='lang', data=df)\nplt.title('Runtime vs Memory Usage')\n`                                                                                                                                                        |
| 10 | **Distribution of work time**                          | `python\nsns.histplot(df['whours'], kde=True, bins=15)\nplt.title('Distribution of Work Hours (whours)')\n`                                                                                                                                                             |
